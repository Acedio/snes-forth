: ' WORD FIND DROP ; LABEL _TICK
: POSTPONE ' COMPILE, ; IMMEDIATE

: ['] A.LIT [ ' A.LIT XT, ] COMPILE, ' XT, ; IMMEDIATE LABEL _BRACKET_TICK

: 0= 0 = ; LABEL _0_EQ
: 0<> 0 <> ; LABEL _0_NE
: 0< 0 < ; LABEL _0_GT
: 0> 0 > ; LABEL _0_LT

: IF ['] BRANCH0 COMPILE, HERE 0 , ; IMMEDIATE
: THEN A.DUP A.>R HERE A.SWAP ADDRESS-OFFSET A.R> ! ; IMMEDIATE
: ELSE ['] BRANCH COMPILE, HERE 0 , A.SWAP POSTPONE THEN ; IMMEDIATE

: BEGIN HERE ; IMMEDIATE
: UNTIL ['] BRANCH0 COMPILE, HERE ADDRESS-OFFSET , ; IMMEDIATE

: WHILE POSTPONE IF A.SWAP ; IMMEDIATE
: REPEAT ['] BRANCH COMPILE, HERE ADDRESS-OFFSET , POSTPONE THEN ; IMMEDIATE

: TEST-UNTIL 1 BEGIN DUP 1+ DUP 5 = UNTIL ;

: TEST-WHILE 1 BEGIN DUP 5 < WHILE DUP 1+ REPEAT ;

: CR ." 
" ;

: [CHAR] KEY DROP KEY ['] LIT COMPILE, , ; IMMEDIATE

: ( BEGIN KEY [CHAR] ) = UNTIL ; IMMEDIATE LABEL _L_PAREN

( Do comments work now? )

( Seems like it!
  Woohoo! We can finally comment our Forth code! )

( I feel like the way I'm grabbing a CR char here probably isn't portable. )
: \ BEGIN KEY [CHAR] 
= UNTIL ; IMMEDIATE LABEL _BACKSLASH

: MATH-OP-TEST
  0 1 +
  -1 -2 -
  0x00 0x01 OR
  0x05 0x03 AND
  0x03 0x02 XOR
  0xFFFE INVERT
  0xFFFF NEGATE
;

: COMPARISON-TEST
  1 2 <
  2 1 <
  2 1 >
  1 2 >
  1 1 =
  0 1 =
  0 1 <>
  1 1 <>
  0xFFFE 0xFFFF U<
  0xFFFF 0xFFFE U<
  0xFFFF 0xFFFE U>
  0xFFFE 0xFFFF U>
;

: MAIN MATH-OP-TEST ;

MAIN
